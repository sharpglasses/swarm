// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: content.proto

#ifndef PROTOBUF_content_2eproto__INCLUDED
#define PROTOBUF_content_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace swarm {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_content_2eproto();
void protobuf_AssignDesc_content_2eproto();
void protobuf_ShutdownFile_content_2eproto();

class PbRequest;
class PbEmit;
class PbDispatch;
class PbDispatch_PbVariable;
class PbContent;
class PbContentList;

// ===================================================================

class PbRequest : public ::google::protobuf::Message {
 public:
  PbRequest();
  virtual ~PbRequest();
  
  PbRequest(const PbRequest& from);
  
  inline PbRequest& operator=(const PbRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PbRequest& default_instance();
  
  void Swap(PbRequest* other);
  
  // implements Message ----------------------------------------------
  
  PbRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PbRequest& from);
  void MergeFrom(const PbRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 tv_sec = 1;
  inline bool has_tv_sec() const;
  inline void clear_tv_sec();
  static const int kTvSecFieldNumber = 1;
  inline ::google::protobuf::uint32 tv_sec() const;
  inline void set_tv_sec(::google::protobuf::uint32 value);
  
  // required uint32 tv_usec = 2;
  inline bool has_tv_usec() const;
  inline void clear_tv_usec();
  static const int kTvUsecFieldNumber = 2;
  inline ::google::protobuf::uint32 tv_usec() const;
  inline void set_tv_usec(::google::protobuf::uint32 value);
  
  // required int32 frame_id = 3;
  inline bool has_frame_id() const;
  inline void clear_frame_id();
  static const int kFrameIdFieldNumber = 3;
  inline ::google::protobuf::int32 frame_id() const;
  inline void set_frame_id(::google::protobuf::int32 value);
  
  // required bytes payload = 4;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 4;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  
  // optional int32 decoder = 5;
  inline bool has_decoder() const;
  inline void clear_decoder();
  static const int kDecoderFieldNumber = 5;
  inline ::google::protobuf::int32 decoder() const;
  inline void set_decoder(::google::protobuf::int32 value);
  
  // optional bytes src_addr = 6;
  inline bool has_src_addr() const;
  inline void clear_src_addr();
  static const int kSrcAddrFieldNumber = 6;
  inline const ::std::string& src_addr() const;
  inline void set_src_addr(const ::std::string& value);
  inline void set_src_addr(const char* value);
  inline void set_src_addr(const void* value, size_t size);
  inline ::std::string* mutable_src_addr();
  inline ::std::string* release_src_addr();
  
  // optional bytes dst_addr = 7;
  inline bool has_dst_addr() const;
  inline void clear_dst_addr();
  static const int kDstAddrFieldNumber = 7;
  inline const ::std::string& dst_addr() const;
  inline void set_dst_addr(const ::std::string& value);
  inline void set_dst_addr(const char* value);
  inline void set_dst_addr(const void* value, size_t size);
  inline ::std::string* mutable_dst_addr();
  inline ::std::string* release_dst_addr();
  
  // optional int32 proto = 8;
  inline bool has_proto() const;
  inline void clear_proto();
  static const int kProtoFieldNumber = 8;
  inline ::google::protobuf::int32 proto() const;
  inline void set_proto(::google::protobuf::int32 value);
  
  // optional int32 src_port = 9;
  inline bool has_src_port() const;
  inline void clear_src_port();
  static const int kSrcPortFieldNumber = 9;
  inline ::google::protobuf::int32 src_port() const;
  inline void set_src_port(::google::protobuf::int32 value);
  
  // optional int32 dst_port = 10;
  inline bool has_dst_port() const;
  inline void clear_dst_port();
  static const int kDstPortFieldNumber = 10;
  inline ::google::protobuf::int32 dst_port() const;
  inline void set_dst_port(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:swarm.PbRequest)
 private:
  inline void set_has_tv_sec();
  inline void clear_has_tv_sec();
  inline void set_has_tv_usec();
  inline void clear_has_tv_usec();
  inline void set_has_frame_id();
  inline void clear_has_frame_id();
  inline void set_has_payload();
  inline void clear_has_payload();
  inline void set_has_decoder();
  inline void clear_has_decoder();
  inline void set_has_src_addr();
  inline void clear_has_src_addr();
  inline void set_has_dst_addr();
  inline void clear_has_dst_addr();
  inline void set_has_proto();
  inline void clear_has_proto();
  inline void set_has_src_port();
  inline void clear_has_src_port();
  inline void set_has_dst_port();
  inline void clear_has_dst_port();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 tv_sec_;
  ::google::protobuf::uint32 tv_usec_;
  ::std::string* payload_;
  ::google::protobuf::int32 frame_id_;
  ::google::protobuf::int32 decoder_;
  ::std::string* src_addr_;
  ::std::string* dst_addr_;
  ::google::protobuf::int32 proto_;
  ::google::protobuf::int32 src_port_;
  ::google::protobuf::int32 dst_port_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_content_2eproto();
  friend void protobuf_AssignDesc_content_2eproto();
  friend void protobuf_ShutdownFile_content_2eproto();
  
  void InitAsDefaultInstance();
  static PbRequest* default_instance_;
};
// -------------------------------------------------------------------

class PbEmit : public ::google::protobuf::Message {
 public:
  PbEmit();
  virtual ~PbEmit();
  
  PbEmit(const PbEmit& from);
  
  inline PbEmit& operator=(const PbEmit& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PbEmit& default_instance();
  
  void Swap(PbEmit* other);
  
  // implements Message ----------------------------------------------
  
  PbEmit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PbEmit& from);
  void MergeFrom(const PbEmit& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes payload = 1;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 1;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  inline ::std::string* release_payload();
  
  // required int32 next = 2;
  inline bool has_next() const;
  inline void clear_next();
  static const int kNextFieldNumber = 2;
  inline ::google::protobuf::int32 next() const;
  inline void set_next(::google::protobuf::int32 value);
  
  // optional bytes src_addr = 3;
  inline bool has_src_addr() const;
  inline void clear_src_addr();
  static const int kSrcAddrFieldNumber = 3;
  inline const ::std::string& src_addr() const;
  inline void set_src_addr(const ::std::string& value);
  inline void set_src_addr(const char* value);
  inline void set_src_addr(const void* value, size_t size);
  inline ::std::string* mutable_src_addr();
  inline ::std::string* release_src_addr();
  
  // optional bytes dst_addr = 4;
  inline bool has_dst_addr() const;
  inline void clear_dst_addr();
  static const int kDstAddrFieldNumber = 4;
  inline const ::std::string& dst_addr() const;
  inline void set_dst_addr(const ::std::string& value);
  inline void set_dst_addr(const char* value);
  inline void set_dst_addr(const void* value, size_t size);
  inline ::std::string* mutable_dst_addr();
  inline ::std::string* release_dst_addr();
  
  // optional int32 proto = 5;
  inline bool has_proto() const;
  inline void clear_proto();
  static const int kProtoFieldNumber = 5;
  inline ::google::protobuf::int32 proto() const;
  inline void set_proto(::google::protobuf::int32 value);
  
  // optional int32 src_port = 6;
  inline bool has_src_port() const;
  inline void clear_src_port();
  static const int kSrcPortFieldNumber = 6;
  inline ::google::protobuf::int32 src_port() const;
  inline void set_src_port(::google::protobuf::int32 value);
  
  // optional int32 dst_port = 7;
  inline bool has_dst_port() const;
  inline void clear_dst_port();
  static const int kDstPortFieldNumber = 7;
  inline ::google::protobuf::int32 dst_port() const;
  inline void set_dst_port(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:swarm.PbEmit)
 private:
  inline void set_has_payload();
  inline void clear_has_payload();
  inline void set_has_next();
  inline void clear_has_next();
  inline void set_has_src_addr();
  inline void clear_has_src_addr();
  inline void set_has_dst_addr();
  inline void clear_has_dst_addr();
  inline void set_has_proto();
  inline void clear_has_proto();
  inline void set_has_src_port();
  inline void clear_has_src_port();
  inline void set_has_dst_port();
  inline void clear_has_dst_port();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* payload_;
  ::std::string* src_addr_;
  ::google::protobuf::int32 next_;
  ::google::protobuf::int32 proto_;
  ::std::string* dst_addr_;
  ::google::protobuf::int32 src_port_;
  ::google::protobuf::int32 dst_port_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_content_2eproto();
  friend void protobuf_AssignDesc_content_2eproto();
  friend void protobuf_ShutdownFile_content_2eproto();
  
  void InitAsDefaultInstance();
  static PbEmit* default_instance_;
};
// -------------------------------------------------------------------

class PbDispatch_PbVariable : public ::google::protobuf::Message {
 public:
  PbDispatch_PbVariable();
  virtual ~PbDispatch_PbVariable();
  
  PbDispatch_PbVariable(const PbDispatch_PbVariable& from);
  
  inline PbDispatch_PbVariable& operator=(const PbDispatch_PbVariable& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PbDispatch_PbVariable& default_instance();
  
  void Swap(PbDispatch_PbVariable* other);
  
  // implements Message ----------------------------------------------
  
  PbDispatch_PbVariable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PbDispatch_PbVariable& from);
  void MergeFrom(const PbDispatch_PbVariable& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline ::google::protobuf::uint32 key() const;
  inline void set_key(::google::protobuf::uint32 value);
  
  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  
  // required uint32 idx = 3;
  inline bool has_idx() const;
  inline void clear_idx();
  static const int kIdxFieldNumber = 3;
  inline ::google::protobuf::uint32 idx() const;
  inline void set_idx(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:swarm.PbDispatch.PbVariable)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_data();
  inline void clear_has_data();
  inline void set_has_idx();
  inline void clear_has_idx();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* data_;
  ::google::protobuf::uint32 key_;
  ::google::protobuf::uint32 idx_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_content_2eproto();
  friend void protobuf_AssignDesc_content_2eproto();
  friend void protobuf_ShutdownFile_content_2eproto();
  
  void InitAsDefaultInstance();
  static PbDispatch_PbVariable* default_instance_;
};
// -------------------------------------------------------------------

class PbDispatch : public ::google::protobuf::Message {
 public:
  PbDispatch();
  virtual ~PbDispatch();
  
  PbDispatch(const PbDispatch& from);
  
  inline PbDispatch& operator=(const PbDispatch& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PbDispatch& default_instance();
  
  void Swap(PbDispatch* other);
  
  // implements Message ----------------------------------------------
  
  PbDispatch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PbDispatch& from);
  void MergeFrom(const PbDispatch& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef PbDispatch_PbVariable PbVariable;
  
  // accessors -------------------------------------------------------
  
  // required uint32 event = 1;
  inline bool has_event() const;
  inline void clear_event();
  static const int kEventFieldNumber = 1;
  inline ::google::protobuf::uint32 event() const;
  inline void set_event(::google::protobuf::uint32 value);
  
  // repeated .swarm.PbDispatch.PbVariable var = 2;
  inline int var_size() const;
  inline void clear_var();
  static const int kVarFieldNumber = 2;
  inline const ::swarm::PbDispatch_PbVariable& var(int index) const;
  inline ::swarm::PbDispatch_PbVariable* mutable_var(int index);
  inline ::swarm::PbDispatch_PbVariable* add_var();
  inline const ::google::protobuf::RepeatedPtrField< ::swarm::PbDispatch_PbVariable >&
      var() const;
  inline ::google::protobuf::RepeatedPtrField< ::swarm::PbDispatch_PbVariable >*
      mutable_var();
  
  // @@protoc_insertion_point(class_scope:swarm.PbDispatch)
 private:
  inline void set_has_event();
  inline void clear_has_event();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::swarm::PbDispatch_PbVariable > var_;
  ::google::protobuf::uint32 event_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_content_2eproto();
  friend void protobuf_AssignDesc_content_2eproto();
  friend void protobuf_ShutdownFile_content_2eproto();
  
  void InitAsDefaultInstance();
  static PbDispatch* default_instance_;
};
// -------------------------------------------------------------------

class PbContent : public ::google::protobuf::Message {
 public:
  PbContent();
  virtual ~PbContent();
  
  PbContent(const PbContent& from);
  
  inline PbContent& operator=(const PbContent& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PbContent& default_instance();
  
  void Swap(PbContent* other);
  
  // implements Message ----------------------------------------------
  
  PbContent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PbContent& from);
  void MergeFrom(const PbContent& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .swarm.PbRequest req = 1;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 1;
  inline const ::swarm::PbRequest& req() const;
  inline ::swarm::PbRequest* mutable_req();
  inline ::swarm::PbRequest* release_req();
  
  // optional .swarm.PbEmit emit = 2;
  inline bool has_emit() const;
  inline void clear_emit();
  static const int kEmitFieldNumber = 2;
  inline const ::swarm::PbEmit& emit() const;
  inline ::swarm::PbEmit* mutable_emit();
  inline ::swarm::PbEmit* release_emit();
  
  // repeated .swarm.PbDispatch disp = 3;
  inline int disp_size() const;
  inline void clear_disp();
  static const int kDispFieldNumber = 3;
  inline const ::swarm::PbDispatch& disp(int index) const;
  inline ::swarm::PbDispatch* mutable_disp(int index);
  inline ::swarm::PbDispatch* add_disp();
  inline const ::google::protobuf::RepeatedPtrField< ::swarm::PbDispatch >&
      disp() const;
  inline ::google::protobuf::RepeatedPtrField< ::swarm::PbDispatch >*
      mutable_disp();
  
  // @@protoc_insertion_point(class_scope:swarm.PbContent)
 private:
  inline void set_has_req();
  inline void clear_has_req();
  inline void set_has_emit();
  inline void clear_has_emit();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::swarm::PbRequest* req_;
  ::swarm::PbEmit* emit_;
  ::google::protobuf::RepeatedPtrField< ::swarm::PbDispatch > disp_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_content_2eproto();
  friend void protobuf_AssignDesc_content_2eproto();
  friend void protobuf_ShutdownFile_content_2eproto();
  
  void InitAsDefaultInstance();
  static PbContent* default_instance_;
};
// -------------------------------------------------------------------

class PbContentList : public ::google::protobuf::Message {
 public:
  PbContentList();
  virtual ~PbContentList();
  
  PbContentList(const PbContentList& from);
  
  inline PbContentList& operator=(const PbContentList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PbContentList& default_instance();
  
  void Swap(PbContentList* other);
  
  // implements Message ----------------------------------------------
  
  PbContentList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PbContentList& from);
  void MergeFrom(const PbContentList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string next_file = 1;
  inline bool has_next_file() const;
  inline void clear_next_file();
  static const int kNextFileFieldNumber = 1;
  inline const ::std::string& next_file() const;
  inline void set_next_file(const ::std::string& value);
  inline void set_next_file(const char* value);
  inline void set_next_file(const char* value, size_t size);
  inline ::std::string* mutable_next_file();
  inline ::std::string* release_next_file();
  
  // repeated .swarm.PbContent content = 2;
  inline int content_size() const;
  inline void clear_content();
  static const int kContentFieldNumber = 2;
  inline const ::swarm::PbContent& content(int index) const;
  inline ::swarm::PbContent* mutable_content(int index);
  inline ::swarm::PbContent* add_content();
  inline const ::google::protobuf::RepeatedPtrField< ::swarm::PbContent >&
      content() const;
  inline ::google::protobuf::RepeatedPtrField< ::swarm::PbContent >*
      mutable_content();
  
  // @@protoc_insertion_point(class_scope:swarm.PbContentList)
 private:
  inline void set_has_next_file();
  inline void clear_has_next_file();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* next_file_;
  ::google::protobuf::RepeatedPtrField< ::swarm::PbContent > content_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_content_2eproto();
  friend void protobuf_AssignDesc_content_2eproto();
  friend void protobuf_ShutdownFile_content_2eproto();
  
  void InitAsDefaultInstance();
  static PbContentList* default_instance_;
};
// ===================================================================


// ===================================================================

// PbRequest

// required uint32 tv_sec = 1;
inline bool PbRequest::has_tv_sec() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PbRequest::set_has_tv_sec() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PbRequest::clear_has_tv_sec() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PbRequest::clear_tv_sec() {
  tv_sec_ = 0u;
  clear_has_tv_sec();
}
inline ::google::protobuf::uint32 PbRequest::tv_sec() const {
  return tv_sec_;
}
inline void PbRequest::set_tv_sec(::google::protobuf::uint32 value) {
  set_has_tv_sec();
  tv_sec_ = value;
}

// required uint32 tv_usec = 2;
inline bool PbRequest::has_tv_usec() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PbRequest::set_has_tv_usec() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PbRequest::clear_has_tv_usec() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PbRequest::clear_tv_usec() {
  tv_usec_ = 0u;
  clear_has_tv_usec();
}
inline ::google::protobuf::uint32 PbRequest::tv_usec() const {
  return tv_usec_;
}
inline void PbRequest::set_tv_usec(::google::protobuf::uint32 value) {
  set_has_tv_usec();
  tv_usec_ = value;
}

// required int32 frame_id = 3;
inline bool PbRequest::has_frame_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PbRequest::set_has_frame_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PbRequest::clear_has_frame_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PbRequest::clear_frame_id() {
  frame_id_ = 0;
  clear_has_frame_id();
}
inline ::google::protobuf::int32 PbRequest::frame_id() const {
  return frame_id_;
}
inline void PbRequest::set_frame_id(::google::protobuf::int32 value) {
  set_has_frame_id();
  frame_id_ = value;
}

// required bytes payload = 4;
inline bool PbRequest::has_payload() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PbRequest::set_has_payload() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PbRequest::clear_has_payload() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PbRequest::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& PbRequest::payload() const {
  return *payload_;
}
inline void PbRequest::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void PbRequest::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void PbRequest::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PbRequest::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* PbRequest::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 decoder = 5;
inline bool PbRequest::has_decoder() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PbRequest::set_has_decoder() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PbRequest::clear_has_decoder() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PbRequest::clear_decoder() {
  decoder_ = 0;
  clear_has_decoder();
}
inline ::google::protobuf::int32 PbRequest::decoder() const {
  return decoder_;
}
inline void PbRequest::set_decoder(::google::protobuf::int32 value) {
  set_has_decoder();
  decoder_ = value;
}

// optional bytes src_addr = 6;
inline bool PbRequest::has_src_addr() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PbRequest::set_has_src_addr() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PbRequest::clear_has_src_addr() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PbRequest::clear_src_addr() {
  if (src_addr_ != &::google::protobuf::internal::kEmptyString) {
    src_addr_->clear();
  }
  clear_has_src_addr();
}
inline const ::std::string& PbRequest::src_addr() const {
  return *src_addr_;
}
inline void PbRequest::set_src_addr(const ::std::string& value) {
  set_has_src_addr();
  if (src_addr_ == &::google::protobuf::internal::kEmptyString) {
    src_addr_ = new ::std::string;
  }
  src_addr_->assign(value);
}
inline void PbRequest::set_src_addr(const char* value) {
  set_has_src_addr();
  if (src_addr_ == &::google::protobuf::internal::kEmptyString) {
    src_addr_ = new ::std::string;
  }
  src_addr_->assign(value);
}
inline void PbRequest::set_src_addr(const void* value, size_t size) {
  set_has_src_addr();
  if (src_addr_ == &::google::protobuf::internal::kEmptyString) {
    src_addr_ = new ::std::string;
  }
  src_addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PbRequest::mutable_src_addr() {
  set_has_src_addr();
  if (src_addr_ == &::google::protobuf::internal::kEmptyString) {
    src_addr_ = new ::std::string;
  }
  return src_addr_;
}
inline ::std::string* PbRequest::release_src_addr() {
  clear_has_src_addr();
  if (src_addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = src_addr_;
    src_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes dst_addr = 7;
inline bool PbRequest::has_dst_addr() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PbRequest::set_has_dst_addr() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PbRequest::clear_has_dst_addr() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PbRequest::clear_dst_addr() {
  if (dst_addr_ != &::google::protobuf::internal::kEmptyString) {
    dst_addr_->clear();
  }
  clear_has_dst_addr();
}
inline const ::std::string& PbRequest::dst_addr() const {
  return *dst_addr_;
}
inline void PbRequest::set_dst_addr(const ::std::string& value) {
  set_has_dst_addr();
  if (dst_addr_ == &::google::protobuf::internal::kEmptyString) {
    dst_addr_ = new ::std::string;
  }
  dst_addr_->assign(value);
}
inline void PbRequest::set_dst_addr(const char* value) {
  set_has_dst_addr();
  if (dst_addr_ == &::google::protobuf::internal::kEmptyString) {
    dst_addr_ = new ::std::string;
  }
  dst_addr_->assign(value);
}
inline void PbRequest::set_dst_addr(const void* value, size_t size) {
  set_has_dst_addr();
  if (dst_addr_ == &::google::protobuf::internal::kEmptyString) {
    dst_addr_ = new ::std::string;
  }
  dst_addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PbRequest::mutable_dst_addr() {
  set_has_dst_addr();
  if (dst_addr_ == &::google::protobuf::internal::kEmptyString) {
    dst_addr_ = new ::std::string;
  }
  return dst_addr_;
}
inline ::std::string* PbRequest::release_dst_addr() {
  clear_has_dst_addr();
  if (dst_addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dst_addr_;
    dst_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 proto = 8;
inline bool PbRequest::has_proto() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PbRequest::set_has_proto() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PbRequest::clear_has_proto() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PbRequest::clear_proto() {
  proto_ = 0;
  clear_has_proto();
}
inline ::google::protobuf::int32 PbRequest::proto() const {
  return proto_;
}
inline void PbRequest::set_proto(::google::protobuf::int32 value) {
  set_has_proto();
  proto_ = value;
}

// optional int32 src_port = 9;
inline bool PbRequest::has_src_port() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PbRequest::set_has_src_port() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PbRequest::clear_has_src_port() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PbRequest::clear_src_port() {
  src_port_ = 0;
  clear_has_src_port();
}
inline ::google::protobuf::int32 PbRequest::src_port() const {
  return src_port_;
}
inline void PbRequest::set_src_port(::google::protobuf::int32 value) {
  set_has_src_port();
  src_port_ = value;
}

// optional int32 dst_port = 10;
inline bool PbRequest::has_dst_port() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PbRequest::set_has_dst_port() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PbRequest::clear_has_dst_port() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PbRequest::clear_dst_port() {
  dst_port_ = 0;
  clear_has_dst_port();
}
inline ::google::protobuf::int32 PbRequest::dst_port() const {
  return dst_port_;
}
inline void PbRequest::set_dst_port(::google::protobuf::int32 value) {
  set_has_dst_port();
  dst_port_ = value;
}

// -------------------------------------------------------------------

// PbEmit

// required bytes payload = 1;
inline bool PbEmit::has_payload() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PbEmit::set_has_payload() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PbEmit::clear_has_payload() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PbEmit::clear_payload() {
  if (payload_ != &::google::protobuf::internal::kEmptyString) {
    payload_->clear();
  }
  clear_has_payload();
}
inline const ::std::string& PbEmit::payload() const {
  return *payload_;
}
inline void PbEmit::set_payload(const ::std::string& value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void PbEmit::set_payload(const char* value) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void PbEmit::set_payload(const void* value, size_t size) {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PbEmit::mutable_payload() {
  set_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    payload_ = new ::std::string;
  }
  return payload_;
}
inline ::std::string* PbEmit::release_payload() {
  clear_has_payload();
  if (payload_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payload_;
    payload_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 next = 2;
inline bool PbEmit::has_next() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PbEmit::set_has_next() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PbEmit::clear_has_next() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PbEmit::clear_next() {
  next_ = 0;
  clear_has_next();
}
inline ::google::protobuf::int32 PbEmit::next() const {
  return next_;
}
inline void PbEmit::set_next(::google::protobuf::int32 value) {
  set_has_next();
  next_ = value;
}

// optional bytes src_addr = 3;
inline bool PbEmit::has_src_addr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PbEmit::set_has_src_addr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PbEmit::clear_has_src_addr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PbEmit::clear_src_addr() {
  if (src_addr_ != &::google::protobuf::internal::kEmptyString) {
    src_addr_->clear();
  }
  clear_has_src_addr();
}
inline const ::std::string& PbEmit::src_addr() const {
  return *src_addr_;
}
inline void PbEmit::set_src_addr(const ::std::string& value) {
  set_has_src_addr();
  if (src_addr_ == &::google::protobuf::internal::kEmptyString) {
    src_addr_ = new ::std::string;
  }
  src_addr_->assign(value);
}
inline void PbEmit::set_src_addr(const char* value) {
  set_has_src_addr();
  if (src_addr_ == &::google::protobuf::internal::kEmptyString) {
    src_addr_ = new ::std::string;
  }
  src_addr_->assign(value);
}
inline void PbEmit::set_src_addr(const void* value, size_t size) {
  set_has_src_addr();
  if (src_addr_ == &::google::protobuf::internal::kEmptyString) {
    src_addr_ = new ::std::string;
  }
  src_addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PbEmit::mutable_src_addr() {
  set_has_src_addr();
  if (src_addr_ == &::google::protobuf::internal::kEmptyString) {
    src_addr_ = new ::std::string;
  }
  return src_addr_;
}
inline ::std::string* PbEmit::release_src_addr() {
  clear_has_src_addr();
  if (src_addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = src_addr_;
    src_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes dst_addr = 4;
inline bool PbEmit::has_dst_addr() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PbEmit::set_has_dst_addr() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PbEmit::clear_has_dst_addr() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PbEmit::clear_dst_addr() {
  if (dst_addr_ != &::google::protobuf::internal::kEmptyString) {
    dst_addr_->clear();
  }
  clear_has_dst_addr();
}
inline const ::std::string& PbEmit::dst_addr() const {
  return *dst_addr_;
}
inline void PbEmit::set_dst_addr(const ::std::string& value) {
  set_has_dst_addr();
  if (dst_addr_ == &::google::protobuf::internal::kEmptyString) {
    dst_addr_ = new ::std::string;
  }
  dst_addr_->assign(value);
}
inline void PbEmit::set_dst_addr(const char* value) {
  set_has_dst_addr();
  if (dst_addr_ == &::google::protobuf::internal::kEmptyString) {
    dst_addr_ = new ::std::string;
  }
  dst_addr_->assign(value);
}
inline void PbEmit::set_dst_addr(const void* value, size_t size) {
  set_has_dst_addr();
  if (dst_addr_ == &::google::protobuf::internal::kEmptyString) {
    dst_addr_ = new ::std::string;
  }
  dst_addr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PbEmit::mutable_dst_addr() {
  set_has_dst_addr();
  if (dst_addr_ == &::google::protobuf::internal::kEmptyString) {
    dst_addr_ = new ::std::string;
  }
  return dst_addr_;
}
inline ::std::string* PbEmit::release_dst_addr() {
  clear_has_dst_addr();
  if (dst_addr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dst_addr_;
    dst_addr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 proto = 5;
inline bool PbEmit::has_proto() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PbEmit::set_has_proto() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PbEmit::clear_has_proto() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PbEmit::clear_proto() {
  proto_ = 0;
  clear_has_proto();
}
inline ::google::protobuf::int32 PbEmit::proto() const {
  return proto_;
}
inline void PbEmit::set_proto(::google::protobuf::int32 value) {
  set_has_proto();
  proto_ = value;
}

// optional int32 src_port = 6;
inline bool PbEmit::has_src_port() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PbEmit::set_has_src_port() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PbEmit::clear_has_src_port() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PbEmit::clear_src_port() {
  src_port_ = 0;
  clear_has_src_port();
}
inline ::google::protobuf::int32 PbEmit::src_port() const {
  return src_port_;
}
inline void PbEmit::set_src_port(::google::protobuf::int32 value) {
  set_has_src_port();
  src_port_ = value;
}

// optional int32 dst_port = 7;
inline bool PbEmit::has_dst_port() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PbEmit::set_has_dst_port() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PbEmit::clear_has_dst_port() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PbEmit::clear_dst_port() {
  dst_port_ = 0;
  clear_has_dst_port();
}
inline ::google::protobuf::int32 PbEmit::dst_port() const {
  return dst_port_;
}
inline void PbEmit::set_dst_port(::google::protobuf::int32 value) {
  set_has_dst_port();
  dst_port_ = value;
}

// -------------------------------------------------------------------

// PbDispatch_PbVariable

// required uint32 key = 1;
inline bool PbDispatch_PbVariable::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PbDispatch_PbVariable::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PbDispatch_PbVariable::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PbDispatch_PbVariable::clear_key() {
  key_ = 0u;
  clear_has_key();
}
inline ::google::protobuf::uint32 PbDispatch_PbVariable::key() const {
  return key_;
}
inline void PbDispatch_PbVariable::set_key(::google::protobuf::uint32 value) {
  set_has_key();
  key_ = value;
}

// required bytes data = 2;
inline bool PbDispatch_PbVariable::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PbDispatch_PbVariable::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PbDispatch_PbVariable::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PbDispatch_PbVariable::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& PbDispatch_PbVariable::data() const {
  return *data_;
}
inline void PbDispatch_PbVariable::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void PbDispatch_PbVariable::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void PbDispatch_PbVariable::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PbDispatch_PbVariable::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* PbDispatch_PbVariable::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required uint32 idx = 3;
inline bool PbDispatch_PbVariable::has_idx() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PbDispatch_PbVariable::set_has_idx() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PbDispatch_PbVariable::clear_has_idx() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PbDispatch_PbVariable::clear_idx() {
  idx_ = 0u;
  clear_has_idx();
}
inline ::google::protobuf::uint32 PbDispatch_PbVariable::idx() const {
  return idx_;
}
inline void PbDispatch_PbVariable::set_idx(::google::protobuf::uint32 value) {
  set_has_idx();
  idx_ = value;
}

// -------------------------------------------------------------------

// PbDispatch

// required uint32 event = 1;
inline bool PbDispatch::has_event() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PbDispatch::set_has_event() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PbDispatch::clear_has_event() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PbDispatch::clear_event() {
  event_ = 0u;
  clear_has_event();
}
inline ::google::protobuf::uint32 PbDispatch::event() const {
  return event_;
}
inline void PbDispatch::set_event(::google::protobuf::uint32 value) {
  set_has_event();
  event_ = value;
}

// repeated .swarm.PbDispatch.PbVariable var = 2;
inline int PbDispatch::var_size() const {
  return var_.size();
}
inline void PbDispatch::clear_var() {
  var_.Clear();
}
inline const ::swarm::PbDispatch_PbVariable& PbDispatch::var(int index) const {
  return var_.Get(index);
}
inline ::swarm::PbDispatch_PbVariable* PbDispatch::mutable_var(int index) {
  return var_.Mutable(index);
}
inline ::swarm::PbDispatch_PbVariable* PbDispatch::add_var() {
  return var_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::swarm::PbDispatch_PbVariable >&
PbDispatch::var() const {
  return var_;
}
inline ::google::protobuf::RepeatedPtrField< ::swarm::PbDispatch_PbVariable >*
PbDispatch::mutable_var() {
  return &var_;
}

// -------------------------------------------------------------------

// PbContent

// required .swarm.PbRequest req = 1;
inline bool PbContent::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PbContent::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PbContent::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PbContent::clear_req() {
  if (req_ != NULL) req_->::swarm::PbRequest::Clear();
  clear_has_req();
}
inline const ::swarm::PbRequest& PbContent::req() const {
  return req_ != NULL ? *req_ : *default_instance_->req_;
}
inline ::swarm::PbRequest* PbContent::mutable_req() {
  set_has_req();
  if (req_ == NULL) req_ = new ::swarm::PbRequest;
  return req_;
}
inline ::swarm::PbRequest* PbContent::release_req() {
  clear_has_req();
  ::swarm::PbRequest* temp = req_;
  req_ = NULL;
  return temp;
}

// optional .swarm.PbEmit emit = 2;
inline bool PbContent::has_emit() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PbContent::set_has_emit() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PbContent::clear_has_emit() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PbContent::clear_emit() {
  if (emit_ != NULL) emit_->::swarm::PbEmit::Clear();
  clear_has_emit();
}
inline const ::swarm::PbEmit& PbContent::emit() const {
  return emit_ != NULL ? *emit_ : *default_instance_->emit_;
}
inline ::swarm::PbEmit* PbContent::mutable_emit() {
  set_has_emit();
  if (emit_ == NULL) emit_ = new ::swarm::PbEmit;
  return emit_;
}
inline ::swarm::PbEmit* PbContent::release_emit() {
  clear_has_emit();
  ::swarm::PbEmit* temp = emit_;
  emit_ = NULL;
  return temp;
}

// repeated .swarm.PbDispatch disp = 3;
inline int PbContent::disp_size() const {
  return disp_.size();
}
inline void PbContent::clear_disp() {
  disp_.Clear();
}
inline const ::swarm::PbDispatch& PbContent::disp(int index) const {
  return disp_.Get(index);
}
inline ::swarm::PbDispatch* PbContent::mutable_disp(int index) {
  return disp_.Mutable(index);
}
inline ::swarm::PbDispatch* PbContent::add_disp() {
  return disp_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::swarm::PbDispatch >&
PbContent::disp() const {
  return disp_;
}
inline ::google::protobuf::RepeatedPtrField< ::swarm::PbDispatch >*
PbContent::mutable_disp() {
  return &disp_;
}

// -------------------------------------------------------------------

// PbContentList

// optional string next_file = 1;
inline bool PbContentList::has_next_file() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PbContentList::set_has_next_file() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PbContentList::clear_has_next_file() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PbContentList::clear_next_file() {
  if (next_file_ != &::google::protobuf::internal::kEmptyString) {
    next_file_->clear();
  }
  clear_has_next_file();
}
inline const ::std::string& PbContentList::next_file() const {
  return *next_file_;
}
inline void PbContentList::set_next_file(const ::std::string& value) {
  set_has_next_file();
  if (next_file_ == &::google::protobuf::internal::kEmptyString) {
    next_file_ = new ::std::string;
  }
  next_file_->assign(value);
}
inline void PbContentList::set_next_file(const char* value) {
  set_has_next_file();
  if (next_file_ == &::google::protobuf::internal::kEmptyString) {
    next_file_ = new ::std::string;
  }
  next_file_->assign(value);
}
inline void PbContentList::set_next_file(const char* value, size_t size) {
  set_has_next_file();
  if (next_file_ == &::google::protobuf::internal::kEmptyString) {
    next_file_ = new ::std::string;
  }
  next_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PbContentList::mutable_next_file() {
  set_has_next_file();
  if (next_file_ == &::google::protobuf::internal::kEmptyString) {
    next_file_ = new ::std::string;
  }
  return next_file_;
}
inline ::std::string* PbContentList::release_next_file() {
  clear_has_next_file();
  if (next_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = next_file_;
    next_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .swarm.PbContent content = 2;
inline int PbContentList::content_size() const {
  return content_.size();
}
inline void PbContentList::clear_content() {
  content_.Clear();
}
inline const ::swarm::PbContent& PbContentList::content(int index) const {
  return content_.Get(index);
}
inline ::swarm::PbContent* PbContentList::mutable_content(int index) {
  return content_.Mutable(index);
}
inline ::swarm::PbContent* PbContentList::add_content() {
  return content_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::swarm::PbContent >&
PbContentList::content() const {
  return content_;
}
inline ::google::protobuf::RepeatedPtrField< ::swarm::PbContent >*
PbContentList::mutable_content() {
  return &content_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace swarm

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_content_2eproto__INCLUDED
